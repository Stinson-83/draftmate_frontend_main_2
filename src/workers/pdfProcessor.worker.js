/* eslint-disable no-restricted-globals */

// Helper to process elements - Moved from Editor.jsx
const processElements = (elements) => {
    if (elements.length === 0) return '';

    // Group by approximate Y (top) position to form lines
    const rows = new Map();
    const TOLERANCE = 5; // px

    elements.forEach(el => {
        let top = parseFloat(el.style.top || '0');
        // Find existing row within tolerance
        let rowKey = Array.from(rows.keys()).find(k => Math.abs(parseFloat(k) - top) < TOLERANCE);

        if (!rowKey) {
            rowKey = top.toString();
            rows.set(rowKey, []);
        }
        rows.get(rowKey).push(el);
    });

    // Sort rows by Y position
    const sortedRowKeys = Array.from(rows.keys()).sort((a, b) => parseFloat(a) - parseFloat(b));

    // Build new HTML
    let cleanHtml = '';

    sortedRowKeys.forEach(key => {
        const rowElements = rows.get(key);
        // Sort elements in row by X (left) position
        rowElements.sort((a, b) => {
            const leftA = parseFloat(a.style.left || '0');
            const leftB = parseFloat(b.style.left || '0');
            return leftA - leftB;
        });

        // Create a paragraph for this line
        cleanHtml += '<p>';

        let previousRight = 0;

        rowElements.forEach((el, index) => {
            // Extract style metadata we want to preserve
            const styles = el.style;
            const relevantStyles = [];

            if (styles.fontWeight && styles.fontWeight !== 'normal') relevantStyles.push(`font-weight:${styles.fontWeight}`);
            if (styles.fontStyle && styles.fontStyle !== 'normal') relevantStyles.push(`font-style:${styles.fontStyle}`);
            if (styles.textDecoration && styles.textDecoration !== 'none') relevantStyles.push(`text-decoration:${styles.textDecoration}`);
            // if (styles.color && styles.color !== 'rgb(0, 0, 0)' && styles.color !== '#000000') relevantStyles.push(`color:${styles.color}`);
            if (styles.fontSize) relevantStyles.push(`font-size:${styles.fontSize}`);
            // FORCE BLACK COLOR to ensure visibility
            relevantStyles.push('color: black');

            // Calculate Margin for visual spacing
            const left = parseFloat(styles.left || '0');
            const width = parseFloat(styles.width || '0');

            if (index > 0) {
                const gap = left - previousRight;
                // Only add margin if gap is significant (> 5px) to avoid jitter
                if (gap > 5) {
                    relevantStyles.push(`margin-left:${Math.round(gap)}px`);
                } else {
                    // Ensure at least a space if gap is small but positive
                    relevantStyles.push(`margin-left: 4px`);
                }
            }

            // Update previousRight for next element
            // If width is missing (legacy docs), estimate based on text length (approx 7px per char for 12px font)
            const estimatedWidth = width > 0 ? width : (el.innerText.length * 7);
            previousRight = left + estimatedWidth;

            const styleString = relevantStyles.length > 0 ? `style="${relevantStyles.join(';')}"` : '';
            // Use innerHTML from the simplified object
            cleanHtml += `<span ${styleString}>${el.innerHTML}</span>`;
        });

        cleanHtml += '</p>';
    });

    return cleanHtml;
};

self.onmessage = (e) => {
    const { htmlContent } = e.data;

    try {
        // Since we can't use DOMParser with full layout capacity in Worker easily without heavy polyfills,
        // and the previous logic relied on `el.style.top` which comes from parsed DOM.
        // We need a way to parse this. 

        // Actually, simplest way for the worker to handle "style.top" parsing from a string 
        // without a full DOM is using Regex or a lightweight parser. 
        // HOWEVER, the `htmlContent` passed is likely the raw HTML from the server.
        // The server returns HTML with `style="top: ...; left: ..."` in strings.

        // We'll use a regex-based parser or a minimal DOM mock for the worker. 
        // Given complexity, let's use a Regex to extract the specialized elements we care about:
        // .content-element, .text-span, span[style*="absolute"]

        // LIMITATION: Web Workers don't have document/DOMParser.
        // We will do text processing.

        if (!htmlContent.includes('content-element') && !htmlContent.includes('absolute')) {
            self.postMessage({ result: htmlContent });
            return;
        }

        // Rudimentary parser to extract elements with styles
        // This simulates what `doc.querySelectorAll` + loop was doing, but purely via Regex/String processing.
        // This is much faster and non-blocking, but less robust if HTML is very complex.
        // Provided HTML seems to be generated by PDF converter creating spans with inline styles.

        // Pattern to match span/div with style attribute
        // simplified structure: <span class="..." style="...">Content</span>

        // We'll create "Virtual Elements"
        const elementPattern = /<(\w+)[^>]*style="([^"]*)"[^>]*>(.*?)<\/\1>/gis;
        const classPattern = /class="([^"]*)"/i;

        const allElements = [];

        let match;
        while ((match = elementPattern.exec(htmlContent)) !== null) {
            const [fullTag, tagName, styleStr, innerHTML] = match;

            // Check if it's a target element
            const classMatch = classPattern.exec(fullTag);
            const className = classMatch ? classMatch[1] : '';

            const isTarget = className.includes('content-element') ||
                className.includes('text-span') ||
                styleStr.includes('absolute');

            if (isTarget) {
                // Parse styles
                const styles = {};
                styleStr.split(';').forEach(s => {
                    const [k, v] = s.split(':');
                    if (k && v) styles[k.trim()] = v.trim();
                });

                // Helper to get text length for estimation
                const innerText = innerHTML.replace(/<[^>]*>/g, '');

                allElements.push({
                    tagName,
                    style: styles,
                    innerHTML,
                    innerText,
                    // Simulate DOM object for existing logic
                });
            }
        }

        // Reuse processElements logic but adapted for our virtual elements
        // The logic expects `el.style.top` etc. Our `allElements` objects match that structure.

        // Group by Page? The original code had logic for `.pdf-page`.
        // If we have pages, we should process per page.
        // Regex to split by pages? <div class="pdf-page"...>...</div>

        const pagePattern = /<div[^>]*class="[^"]*pdf-page[^"]*"[^>]*>(.*?)<\/div>/gis;
        const pages = [];
        let pageMatch;
        let hasPages = false;

        // Reset regex index for safety if we reused it, but we use new one
        while ((pageMatch = pagePattern.exec(htmlContent)) !== null) {
            hasPages = true;
            pages.push(pageMatch[1]);
        }

        let fullHtml = '';

        if (hasPages) {
            pages.forEach(pageHtml => {
                // Parse elements within page
                const pageElements = [];
                let elMatch;
                // Re-create regex for inner loop to avoid state issues
                const innerElPattern = /<(\w+)[^>]*style="([^"]*)"[^>]*>(.*?)<\/\1>/gis;

                while ((elMatch = innerElPattern.exec(pageHtml)) !== null) {
                    const [fullTag, tagName, styleStr, innerHTML] = elMatch;
                    const classMatch = classPattern.exec(fullTag);
                    const className = classMatch ? classMatch[1] : '';

                    if (className.includes('content-element') || className.includes('text-span') || styleStr.includes('absolute')) {
                        const styles = {};
                        styleStr.split(';').forEach(s => {
                            const [k, v] = s.split(':');
                            if (k && v) styles[k.trim()] = v.trim();
                        });
                        pageElements.push({
                            style: styles,
                            innerHTML,
                            innerText: innerHTML.replace(/<[^>]*>/g, '')
                        });
                    }
                }
                fullHtml += processElements(pageElements);
            });
        } else {
            // No pages, use all elements found primarily
            if (allElements.length > 0) {
                fullHtml = processElements(allElements);
            } else {
                // Fallback if regex failed to find structure but it was expected
                fullHtml = htmlContent;
            }
        }

        self.postMessage({ result: fullHtml || htmlContent });

    } catch (e) {
        console.error("Worker Error:", e);
        // Fallback: return original if we crash
        self.postMessage({ result: htmlContent });
    }
};
